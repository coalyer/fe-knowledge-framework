## 第8章 BOM

***1. 本章内容***

本章内容

- 理解window 对象——BOM的核心
- 控制窗口、框架和弹出窗口
- 利用location 对象中的页面信息
- 使用navigator 对象了解浏览器

***2. BOM***

**ECMAScript 是JavaScript 的核心，但如果要在Web 中使用JavaScript，那么BOM（浏览器对象模型）则无疑才是真正的核心。**

BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。

多年来，缺少事实上的规范导致BOM既有意思又有问题，因为浏览器提供商会按照各自的想法随意去扩展它。于是，浏览器之间共有的对象就成为了事实上的标准。这些对象在浏览器中得以存在，很大程度上是由于它们提供了与浏览器的互操作性。

**W3C 为了把浏览器中JavaScript 最基本的部分标准化，已经将BOM的主要方面纳入了HTML5 的规范中。**

### 8.1 window对象

***1. window 对象***

BOM 的核心对象是window，它表示浏览器的一个实例。

在浏览器中，window 对象有双重角色，它**既是通过JavaScript 访问浏览器窗口的一个接口，又是ECMAScript 规定的Global 对象**。这意味着**在网页中定义的**任何一个对象、变量和函数，**都以window 作为其Global 对象，因此有权访问parseInt()等方法**。

#### 8.1.1 全局作用域

***1. window 对象的属性和方法***

**由于window 对象同时扮演着ECMAScript 中Global 对象的角色**，因此**所有在全局作用域中声明的变量、函数都会变成window 对象的属性和方法**。

来看下面的例子：

```js
var age = 29;
function sayAge(){
	alert(this.age);
}

alert(window.age); //29
sayAge(); //29
window.sayAge(); //29
```

- 我们在全局作用域中定义了一个变量age 和一个函数sayAge()，它们被自动归在了window 对象名下。于是，可以通过window.age 访问变量age，可以通过window.sayAge()访问函数sayAge()。
- **由于sayAge()存在于全局作用域**中，因此this.age 被映射到window.age，最终显示的仍然是正确的结果。

抛开全局变量会成为window 对象的属性不谈，定义全局变量与在window 对象上直接定义属性还是有一点差别：**全局变量不能通过delete 操作符删除，而直接在window 对象上的定义的属性可以。**

```js
var age = 29;
window.color = "red";

//在IE < 9 时抛出错误，在其他所有浏览器中都返回false
delete window.age;

//在IE < 9 时抛出错误，在其他所有浏览器中都返回true
delete window.color; //returns true

alert(window.age); //29
alert(window.color); //undefined
```

- 刚才使用var 语句添加的window 属性有一个名为[[Configurable]]的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete 操作符删除。
- IE8及更早版本在遇到使用delete删除window 属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版本不会抛出错误。

另外，还要记住一件事：尝试访问未声明的变量会抛出错误，但是**通过查询window 对象，可以知道某个可能未声明的变量是否存在。**

例如：

```js
//这里会抛出错误，因为oldValue 未定义
var newValue = oldValue;

//这里不会抛出错误，因为这是一次属性查询
//newValue 的值是undefined
var newValue = window.oldValue;
```

本章后面将要讨论的**很多全局JavaScript 对象（如location 和navigator）实际上都是window对象的属性**。

Windows Mobile 平台的IE 浏览器不允许通过window.property = value 之类的形式，直接在window 对象上创建新的属性或方法。可是，在全局作用域中声明的所有变量和函数，照样会变成window 对象的成员。

#### 8.1.2 窗口关系及框架

***1. 每个框架都拥有自己的window 对象***

如果页面中包含框架，则每个框架都拥有自己的window 对象，

- 并且保存在frames 集合中。在frames集合中，可以通过数值索引（从0 开始，从左至右，从上到下）或者框架名称来访问相应的window 对象。
- 每个window 对象都有一个name 属性，其中包含框架的名称。

下面是一个包含框架的页面：

```js
<html>
	<head>
		<title>Frameset Example</title>
	</head>
	<frameset rows="160,*">
		<frame src="frame.htm" name="topFrame">
		<frameset cols="50%,50%">
			<frame src="anotherframe.htm" name="leftFrame">
			<frame src="yetanotherframe.htm" name="rightFrame">
		</frameset>
	</frameset>
</html>
```

- 以上代码创建了一个框架集，其中一个框架居上，两个框架居下。对这个例子而言，可以通过window.frames[0]或者window.frames["topFrame"]来引用上方的框架。
- 不过，恐怕你最好使用top 而非window 来引用这些框架（例如，通过top.frames[0]）。

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 8.1.3 窗口位置

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 8.1.4 窗口大小

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 8.1.5 导航和打开窗口

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 8.1.6 间歇调用和超时调用

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 8.1.7 系统对话框

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

### 8.2 location对象

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 8.2.1 查询字符串参数

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 8.2.2 位置操作

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

### 8.3 navigator对象

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 8.3.1 检测插件

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

#### 8.3.2 注册处理程序

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

### 8.4 screen对象

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

### 8.5 history对象

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***

### 8.6 小结

***1. ***

***2. ***

***3.***

***4. ***

***5.***

***6. ***